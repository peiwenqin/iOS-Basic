##进程，线程
#####基本理解
**进程**是一个动态过程，是在计算机或者终端上执行的一次活动，当运行了一个程序，其实就是开始了一个进程，进程之间相互独立，拥有自己的内存空间和一定的资源

**线程**是执行命令的最小单位，是进程的实体，程序启动会自动开启一个线程(主线程)，一个进程拥有至少一个线程。CPU 执行任务的时候，同一时间只能在一个线程上，只不过是因为cpu 调度的很快，在多个线程之间切换工作，造成了多线程的假象；合理的使用多线程有利于提高 CPU 的执行效率和资源利用率，但是线程的开辟是占用内存空间的，而且调度多个线程也会消耗 CPU 的效率。

**实现多线程的几种方式**

1、NSThread
   操作很常规
   
   ```
   //1,
    NSThread *thread = [[NSThread alloc] initWithBlock:^{
        //任务
        NSLog(@"11-----%@",[NSThread currentThread]);
    }];
    [thread start];//初始化的需要 start 启动
    thread.name = @"test1";
    thread.threadPriority = 0.8;//0-1 之间,默认 0.5,越高被执行的效率可能会越高
    [thread cancel];
    
    //2,构造器创建新线程---直接执行任务
    [NSThread detachNewThreadWithBlock:^{
        ////任务
        NSLog(@"22-----%@",[NSThread currentThread]);
    }];
   
   ```

2、NSOperation 任务 + NSOperationQueue 队列，是对 GCD 的封装

 **NSOperation:** NSOperationInvocation + NSBlockInvocation都是继承于 NSOperation,还可以自定义

```

//NSOperation
- (void)test2 {
    //都只会添加在当前线程中,并且默认同步执行,所以一般和队列一起使用
    
    //1,
    NSBlockOperation *blockOperation = [NSBlockOperation blockOperationWithBlock:^{
        //执行任务
        NSLog(@"1111---");
    }];
    [blockOperation start];
    
    //2,
    NSInvocationOperation *invocationOperation = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(operationAction) object:@"test"];
    [invocationOperation start];
    
    //3,自定义---继承NSOperation,实现 main（） 方法

    
    //**任务依赖**还能设置任务之间互相依赖,invocationOperation需要在blockOperation完成后才能执行
    [invocationOperation addDependency:blockOperation];
    
    NSOperationQueue *queue = [[NSOperationQueue alloc] init];;
    for (int i = 0; i < 10; i ++) {
        [blockOperation addExecutionBlock:^{
            NSLog(@"-----%d",i);
        }];
    }
    [queue addOperation:blockOperation];
    queue.maxConcurrentOperationCount = 5;//当为 1 的时候表示串行队列,>1 表示并行队列
    
    
}

- (void)operationAction
{
    NSLog(@"2222---");

}

```

3、GCD

优点：1，多核的并行运算；2，自动利用更多的 CPU 内核，发挥效率；3，自动管理线程的生命周期，包括创建，调度，销毁；3，GCD 只需要知道执行的任务


